第二章

![image](img/frontdot.jpg)

制作和使用对象

本章将介绍足够的 C++ 语法和程序构造概念，让你能够编写和运行一些简单的面向对象的程序。在下一章，我将详细介绍“C++ 中的 *C* ”的基本语法。

首先阅读这一章，你将获得用 C++ 对象编程的基本感觉，你也会发现围绕这种语言的热情的一些原因。这应该足以让你看完第三章 ，这可能有点累，因为它包含了 C 语言的大部分细节，这些细节在 C++ 中也是可用的。

用户定义的数据类型或类是 C++ 区别于传统过程语言的地方。 类是一种新的数据类型，你或其他人创建它来解决一种特殊的问题。一旦创建了一个类，任何人都可以使用它，而不需要知道它是如何工作的，甚至不需要知道类是如何构建的。本章将类视为程序中可用的另一种内置数据类型。

其他人创建的类通常被打包成一个库。本章使用了所有 C++ 实现中的几个类库。一个特别重要的标准库是`iostream`，它(*和其他的*)允许你从文件和键盘中读取，并向文件和显示器中写入。您还会看到非常方便的`string`类和来自*标准 C++ 库*的`vector`容器。在本章结束时，你会看到使用一个预定义的类库是多么容易。

为了创建您的第一个程序，您必须了解用于构建应用程序的工具。

语言翻译的过程

所有的计算机语言都是从人类易于理解的东西(*源代码*)翻译成计算机可执行的东西(*机器指令*)。传统上，译者分为两类:*口译员*和*编译员*。

解释程序

解释器将源代码翻译成活动(可能包括多组机器指令)，并立即执行这些活动。例如，BASIC 已经成为一种流行的解释语言。传统的 BASIC 解释器一次翻译并执行一行，然后忘记这一行已经被翻译了。这使得他们很慢，因为他们必须重新翻译任何重复的代码。BASIC 也被编译过，为了速度。更现代的解释器，如 Python 语言的解释器，将整个程序翻译成中间语言，然后由更快的解释器执行。

口译员有很多优势。从编写代码到执行代码的转变几乎是即时的，并且源代码总是可用的，因此当错误发生时解释器可以更加具体。解释者经常提到的好处是易于交互和快速开发(*但不一定是执行*)程序。

在构建大型项目时，解释语言通常有严重的局限性(Python 似乎是个例外)。解释器(*或简化版*)必须一直在内存中执行代码，即使是最快的解释器也可能引入不可接受的速度限制。大多数解释器要求将完整的源代码一次全部带入解释器。这不仅引入了空间限制，如果语言不提供本地化不同代码段效果的工具，还会导致更困难的错误。

编译程序

编译器将源代码直接翻译成汇编语言或机器指令。最终产品是一个或多个包含机器代码的文件。这是一个复杂的过程，通常需要几个步骤。使用编译器，从编写代码到执行代码的过渡时间要长得多。

根据编译程序编写者的敏锐度，编译器生成的程序需要更少的空间来运行，并且运行得更快。尽管大小和速度可能是使用编译器最常引用的原因，但在许多情况下，它们不是最重要的原因。一些语言(如 *C* )被设计成允许程序的各个部分被独立编译。这些片段最终被一个叫做*链接器*的工具组合成一个最终的*可执行*程序。这个过程叫做*单独编译*。

单独编译有很多好处。一个程序，一下子就超过了编译器或编译环境的极限，可以被分段编译。程序可以一次构建和测试一部分。一旦一个部分开始工作，它就可以被保存并作为一个构建模块。被测试和工作的部分的集合可以被合并到*库*中，供其他程序员使用。当每个部分被创建时，其他部分的复杂性被隐藏了。所有这些特性都支持创建大型程序。

随着时间的推移，编译器调试功能已经有了显著的改进。早期的编译器只生成机器码，程序员插入 print 语句，看看是怎么回事。这并不总是有效。现代编译器可以将有关源代码的信息插入到可执行程序中。强大的*源代码级调试器*使用这些信息，通过跟踪源代码来准确显示程序中正在发生的事情。

一些编译器通过执行*内存编译*来解决编译速度问题。大多数编译器处理文件，在编译过程的每一步读写它们。内存编译器将编译程序保存在 ram 中。对于小程序来说，这看起来像解释器一样灵敏。

编译过程

用 *C* 和 C++ 编程，需要了解编译过程中的步骤和工具。一些语言( *C* 和 C++)通过在源代码上运行*预处理器*来开始编译。预处理器是一个简单的程序，它用程序员定义的其他模式替换源代码中的模式(使用*预处理器指令*)。预处理器指令用于节省输入并增加代码的可读性。预处理代码通常被写入中间文件。

*编译器通常分两步工作。第一遍分析预处理代码。*编译器将源代码分解成小单元，并将其组织成一个名为*树*的结构。在表达式“`A + B`”中，元素“`A`”、“`+`”和“`B`”是解析树上的叶子。

一个*全局优化器*是，有时在第一遍和第二遍之间使用，以产生更小、更快的代码。*第二遍，代码生成器遍历解析树，为树的节点生成汇编语言代码或机器码*。如果代码生成器创建汇编代码，那么必须运行汇编程序。这两种情况下的最终结果都是一个对象模块(一个通常具有扩展名`.o` *或* `.obj`的文件)。

使用“对象”这个词来描述机器代码块是一个不幸的产物。这个词在面向对象编程被普遍使用之前就开始使用了。“对象”在讨论编译时与“目标”在同一意义上使用，而在面向对象编程中，它意味着“一个有边界的东西”。

链接器将一系列目标模块组合成一个可执行程序，该程序可由操作系统加载和运行。当一个目标模块中的函数引用另一个目标模块中的函数或变量时，链接器解析这些引用；它确保您声称在编译期间存在的所有外部函数和数据确实存在。链接器还添加了一个特殊的对象模块来执行启动活动。

链接器可以搜索称为库的特殊文件，以解析其所有引用。一个库在一个文件中包含一组目标模块。一个图书馆是由一个叫做*图书馆员*的程序创建和维护的。

静态类型检查

编译器在第一次通过时执行类型检查。类型检查测试函数中参数的正确使用，并防止多种编程错误。由于类型检查发生在编译期间，而不是程序运行时，因此被称为*静态类型检查*。

一些面向对象的语言(特别是 Java)在运行时执行一些类型检查(*动态类型检查*)。如果结合静态类型检查，动态类型检查比单独的静态类型检查更强大。然而，它也增加了程序执行的开销。

C++ *使用静态类型检查*,因为这种语言不能假设任何特定的运行时支持坏操作。静态类型检查通知程序员在编译期间类型的误用，从而最大化执行速度。当你学习 C++ 时，你会发现大多数语言设计决策都倾向于高速的、面向生产的编程，这种编程正是以 C 语言而闻名的*语言。*

在 C++ 中可以禁用静态类型检查。您也可以进行自己的动态类型检查；你只需要写代码。

用于单独编译的工具

在构建大型项目时，单独编译尤其重要。在 C 和 C++ 中，程序可以由小的、可管理的、独立测试的部分组成。将程序分成几个部分的最基本的工具是创建命名子例程或子程序的能力。在 *C* 和 C++ 中，子程序被称为*函数*，函数是可以放在不同文件中的代码片段，可以单独编译。换句话说，函数是代码的原子单位，因为你不能将函数的一部分放在一个文件中，而将另一部分放在另一个文件中；整个函数必须放在一个文件中(尽管*文件可以包含多个函数*)。

当你调用一个函数时，你通常会给它传递一些*参数*，这些参数是你希望函数在执行过程中使用的值。当函数结束时，您通常会得到一个*返回值*，这个值是函数返回给您的结果。也可以编写不带参数也不返回值的函数。

*创建一个有多个文件的程序，一个文件中的函数必须访问其他文件中的函数和数据*。编译一个文件时， *C* 或 C++ 编译器必须知道其他文件中的函数和数据，特别是它们的名字和正确用法。编译器确保函数和数据被正确使用。这个告诉编译器外部函数和数据的名字以及它们应该是什么样子的过程被称为*声明*。一旦你声明了一个函数或变量，编译器知道如何检查以确保它被正确使用。

声明与定义

理解声明和定义之间的差异很重要，因为这些术语将在整本书中被精确地使用。基本上所有的 T2 C 和 C++ 程序都需要声明。在你能写你的第一个程序之前，你需要理解写一个声明的正确方法。

声明为编译器引入了一个名字——一个标识符。它告诉编译器“这个函数或者这个变量在某个地方存在，这里是它应该的样子*。**一个定义，*则表示“在这里做这个变量”或者“在这里做这个函数”它为名字分配存储空间。无论你谈论的是变量还是函数，这个意思都是成立的。在这两种情况下，编译器在定义的时候都会分配存储空间。对于变量，编译器确定该变量有多大，并在内存中生成空间来保存该变量的数据。对于一个函数，编译器生成代码，最终占用内存中的存储空间。

你可以在很多不同的地方声明一个变量或者一个函数，但是在 C 和 C++ 中必须只有一个定义(*这有时被称为 ODR，一个定义规则*)。当链接器联合所有的对象模块时，如果它发现同一个函数或变量有多个定义，它通常会抱怨。

*一个定义也可以是一个声明。*如果编译器之前没有见过名字`x`，而你定义了`int x`，编译器会把这个名字看作一个声明，并立刻为它分配存储空间。

函数声明语法

在 *C* 和 C++ 中的函数声明给出了函数名，传递给函数的参数类型，以及函数的返回值。例如，下面是一个名为`func1( )`的函数的声明，它接受两个整数参数(整数在 *C* /C++ 中用关键字`int`表示)并返回一个整数:

```cpp
int func1(int,int);
```

你看到的第一个关键字是返回值本身:`int`。按照使用顺序，参数在函数名后用括号括起来。分号表示语句的结束；在这种情况下，它告诉编译器“仅此而已—这里没有函数定义！”

C 和 C++ 声明试图模仿项目的使用形式。例如，如果`a`是另一个整数，上面的函数可以这样使用:

```cpp
a = func1(2,3);
```

由于`func1`()返回一个整数， *C* 或 C++ 编译器将检查`func1( )`的使用，以确保`a`可以接受返回值，并且参数是适当的。

函数声明中的参数可能有名字。编译器会忽略这些名称，但它们可以作为助记手段帮助用户记忆。例如，您可以用具有相同含义的不同方式声明`func1( )`,比如:

```cpp
int func1(int length, int width);
```

对于参数列表为空的函数来说， *C* 和 C++ 有很大的区别。在 *C* ，宣言

```cpp
int func2();
```

表示“具有任意数量和类型参数的函数”这防止了类型检查，所以在 C++ 中它意味着“一个没有参数的函数”

函数定义

函数定义看起来像函数声明，除了它们有主体。主体是用大括号括起来的语句的集合。大括号表示代码块的开始和结束。要给`func1( )`一个定义，即*空体*(不包含代码的体)，写

```cpp
int func1(int length, int width) { }
```

请注意，在函数定义中，大括号取代了分号。因为大括号将一个语句或一组语句括起来，所以不需要分号。还要注意，如果要在函数体中使用参数，函数定义中的参数必须有名称(因为这里从来没有使用过，所以它们是可选的)。

变量声明语法

短语*“变量声明”*的含义在历史上一直是混乱和矛盾的，理解正确的定义很重要，这样才能正确地阅读代码。*变量声明告诉编译器一个变量看起来像什么*。上面写着*，*“我知道你以前没见过这个名字，但我保证它存在于某个地方，它是一个 X 类型的变量。”

在函数声明中，给出一个类型(返回值)、函数名、参数列表和一个分号。这足以让编译器判断出这是一个声明，以及函数应该是什么样子。根据推论，变量声明可能是后跟名称的类型。例如，

```cpp
int a;
```

可以使用上面的逻辑将变量`a`声明为一个整数。冲突在这里:上面的代码中有足够的信息让编译器为一个名为`a`的整数创建空间，这就是所发生的事情。为了解决这个难题， *C* 和 C++ 需要一个关键字来说明“这只是一个声明；它在别处有定义。”*关键词是* `extern`。这可能意味着该定义对文件是有用的，或者该定义出现在文件的后面。

声明一个变量而不定义它意味着在变量描述前使用`extern`关键字，就像这样:

```cpp
extern int a;
```

`extern`也可以适用于函数声明。对于`func1( )`，看起来是这样的:

```cpp
extern int func1(int length, int width);
```

该语句相当于前面的`func1( )`声明。由于没有函数体，编译器必须将其视为函数声明，而不是函数定义。因此，`extern`关键字对于函数声明来说是多余的和可选的。很不幸的是， *C* 的设计者没有要求使用`extern`进行函数声明；它会更一致，更少混乱(*但是需要更多的输入，这可能解释了为什么做出这个决定*)。清单 2-1 展示了更多声明和定义的例子。

***[清单 2-1](#_list1)*** 。声明和定义的更多示例

```cpp
//: C02:Declare.cpp
// Demonstrates more Declarations & Definitions extern inti; // Declaration without definition
extern float f(float); // Function declaration

float b;  // Declaration & definition
float f(float a) {     // Definition
  return a + 1.0;
}
int i;    // Definition
int h(int x) {         // Declaration & definition
  return x + 1;
}
int main() {
  b = 1.0;
  i = 2;
  f(b);
  h(i);
} ///:∼
```

在函数声明中，参数标识符是可选的。在定义中，它们是必需的(*只有在 C 语言中需要标识符*，*而不是 C++* )。

包括标题

大多数库包含大量的函数和变量。为了节省工作并确保对这些项目进行外部声明时的一致性， *C* 和 C++ 使用一种叫做*头文件*的设备。头文件是包含库的外部声明的文件；它习惯上的文件扩展名是`.h`，比如`headerfile.h`。

![image](img/sq.jpg) **注意**你可能还会看到一些使用不同扩展名的旧代码，比如`.hxx`或`.hpp`，但这种情况越来越少了。

创建库的程序员提供头文件。要声明库中的函数和外部变量，用户只需包含头文件。要包含一个头文件，使用`#include`预处理指令。这告诉预处理器打开指定的头文件，并在出现`#include`语句的地方插入其内容。一个`#include`可以用两种方式命名一个文件:尖括号(`<>`)或者双引号(" ")。

尖括号中的文件名，例如

```cpp
#include <header>
```

让预处理器以一种特定于您的实现的方式搜索文件，但是通常有某种“包含搜索路径”,您可以在您的环境中或者在编译器命令行上指定。设置搜索路径的机制因机器、操作系统和 C++ 实现而异，可能需要您进行一些调查。

双引号中的文件名，例如

```cpp
#include "local.h"
```

告诉预处理器以一种“实现定义的方式”在(*中根据规范*搜索文件这通常意味着搜索相对于当前目录的文件。如果没有找到文件，那么重新处理`include`指令，就好像它有尖括号而不是引号。

要包含`iostream`头文件，您需要编写

```cpp
#include<iostream>
```

预处理器将找到`iostream`头文件(通常在一个名为`include`的子目录中)并插入它。

标准 C++ 包含格式

随着 C++ 的发展，不同的编译器供应商为文件名选择了不同的扩展名。另外，各种操作系统对文件名都有不同的限制，尤其是对文件名长度的限制。这些问题导致了源代码的可移植性问题。为了平滑这些粗糙的边缘，标准使用了一种格式，允许文件名长于臭名昭著的八个字符，并消除了扩展名。例如，而不是包含`iostream.h`的旧样式，它看起来像

```cpp
#include <iostream.h>
```

你现在可以写了

```cpp
#include <iostream>
```

翻译器可以以适合特定编译器和操作系统需求的方式实现 include 语句，如果需要，可以截断名称并添加扩展名。当然，如果您想在供应商提供支持之前使用这种样式，也可以将编译器供应商提供的头文件复制到没有扩展的头文件中。

从 *C* 继承的库仍然可以使用传统的`.h`扩展。但是，您也可以通过在名称前添加一个“`c`”来将它们用于更现代的 C++ include 样式。因此，

```cpp
#include <stdio.h>
#include <stdlib.h>
```

成为

```cpp
#include <cstdio>
#include <cstdlib>
```

以此类推，对于所有的标准 *C* 头。这给读者提供了一个很好的区别，表明你什么时候使用的是 *C* 和 C++ 库。

新的 include 格式的效果与旧的不一样:使用`.h`得到旧的非模板版本，省略`.h`得到新的模板版本。如果试图在一个程序中混合这两种形式，通常会遇到问题。

连接

链接器收集由编译器生成的目标模块(通常使用类似于`.o`或`.obj`的文件扩展名),使其成为操作系统可以加载和运行的可执行程序。这是编译过程的最后阶段。

链接器特征因系统而异。一般来说，你只需要告诉链接器你想要链接在一起的目标模块和库的名字，以及可执行文件的名字，它就开始工作了。一些系统要求你自己调用链接器。对于大多数 C++ 包，您通过 C++ 编译器调用链接器。在许多情况下，链接器是在不可见的情况下为您调用的。

一些老的链接器不会多次搜索目标文件和库，它们从左到右搜索你给它们的列表。这意味着目标文件和库的顺序可能很重要。如果你有一个直到链接时才出现的神秘问题，一种可能是文件给链接器的顺序。

使用库

现在你已经知道了基本的术语，你可以理解如何使用一个库。要使用库，请按照下列步骤操作。

1.  包括库的头文件。
2.  使用库中的函数和变量。
3.  将库链接到可执行程序中。

当目标模块没有组合成一个库时，这些步骤也适用。包含一个头文件并链接目标模块是在 *C* 和 C++ 中单独编译的基本步骤。

链接器如何搜索库

当您在 *C* 或 C++ 中对函数或变量进行外部引用时，链接器在遇到该引用时，可以做两件事情之一。如果它还没有遇到函数或变量的定义，它将标识符添加到它的“未解析引用”列表中如果链接器已经遇到了定义，则解析引用。

如果链接器在目标模块列表中找不到定义，它将搜索库。库有某种索引，所以链接器不需要查看库中的所有对象模块——它只需要查看索引。当链接器在库中找到一个定义时，整个目标模块(不仅仅是函数定义)都被链接到可执行程序中。注意，整个库并没有被链接，只有库中包含所需定义的对象模块被链接(否则程序会不必要地变大)。如果您想最小化可执行程序的大小，您可以考虑在构建自己的库时，在每个源代码文件中放入一个函数。这需要更多的编辑，但对用户来说是有帮助的。

因为链接器按照您给定的顺序搜索文件，所以您可以在库函数出现之前，通过将带有您自己的函数的文件(使用相同的函数名)插入到列表中来抢占库函数的使用。因为链接器在搜索库之前会使用您的函数来解析对该函数的任何引用，所以使用您的函数而不是库函数。注意，这也可能是一个 bug，这是 C++ 名称空间所不允许的。

秘密添加

当一个 *C* 或 C++ 可执行程序被创建时，某些项目被秘密链接进来。其中之一是启动模块，它包含初始化例程，每当一个 *C* 或 C++ 程序开始执行时，都必须运行这些例程。这些例程设置堆栈并初始化程序中的某些变量。

链接器总是在标准库中搜索程序中调用的任何“标准”函数的编译版本。因为总是要搜索标准库，所以只要在程序中包含适当的头文件，就可以使用该库中的任何内容；你不必告诉它去搜索标准库。例如，`iostream`函数就在标准 C++ 库中。要使用它们，只需包含`<iostream>`头文件。如果使用附加库，必须将库名显式添加到传递给链接器的文件列表中。

使用普通 C 库

仅仅因为你是在用 C++ 写代码，并不妨碍你使用 C 库函数。事实上，整个 *C* 库默认包含在标准 C++ 中。在这些功能中已经为您做了大量的工作，因此它们可以为您节省大量时间。

这本书将在方便的时候使用标准 C++(因此也是标准的 *C* )库函数，但是只使用*标准的*库函数，以确保程序的可移植性。在必须使用非 C++ 标准的库函数的少数情况下，将尽可能使用 POSIX 兼容函数。POSIX 是一种基于 Unix 标准化工作的标准，它包含了超出 C++ 库范围的函数。您通常可以在 Unix(尤其是 Linux)平台上找到 POSIX 函数，而且通常是在 DOS/Windows 下。例如，如果你正在使用多线程，你最好使用 POSIX 线程库，因为这样你的代码会更容易理解、移植和维护(*和 POSIX 线程库通常只使用操作系统的底层线程工具，如果它们被提供的话*)。

你的第一个 C++ 程序

现在，您已经了解了创建和编译程序的基本知识。该程序将使用标准的 C++ `iostream`类。这些读写文件和“标准”输入输出(*通常来自控制台，但可能被重定向到文件或设备*)。在这个简单的程序中，一个流对象将被用来在屏幕上打印一条消息。

使用 iostream 类

要在`iostream`类中声明函数和外部数据，请在语句中包含头文件，如下所示:

```cpp
#include <iostream>
```

第一个程序使用了*标准输出*的概念，意思是“一个通用的发送输出的地方”您将看到以不同方式使用标准输出的其他示例，但是这里它将只进入控制台。`iostream`包自动定义一个名为`cout`的变量(*一个对象*)，该变量接受所有绑定到标准输出的数据。

要将数据发送到标准输出，可以使用操作符`<<`。程序员把这个操作符称为“按位左移”，这将在下一章描述。可以说，按位左移与输出无关。但是 C++ 允许运算符*重载*。当重载一个运算符时，当该运算符用于特定类型的对象时，就赋予了它新的含义。对于`iostream`对象，操作符`<<`表示“发送到”例如，

```cpp
cout << "rowdy!";
```

发送字符串“rowdy！”到名为`cout`(是“控制台输出”的简称)的对象。

这就足够让你开始操作了。 *[第十二章](12.html)* 详细介绍了运算符重载。

命名空间

正如在 *[第一章](01.html)*中提到的，在 *C* 语言中遇到的一个问题是，当你的程序达到一定的规模时，你*的函数和标识符“用完了”。当然，你不会真的没有名字；然而，过一段时间后，想出新的想法确实变得更加困难。更重要的是，当一个程序达到一定的规模时，它通常会被分成几个部分，每个部分都由不同的人或团队来构建和维护。因为 *C* 实际上有一个单一的舞台，所有的标识符和函数名都在那里，这意味着所有的开发人员都必须小心，不要在可能冲突的情况下意外地使用相同的名字。这很快变得乏味、浪费时间，并且最终变得昂贵。*

 *标准 C++ 有一个防止这种冲突的机制:`namespace`关键字。一个库或程序中的每一组 C++ 定义都被*“包装”*在一个名称空间中；如果其他一些定义具有相同的名称，但是在不同的名称空间中，则不存在冲突。

名称空间是一种方便而有用的工具，但是它们的存在意味着在编写任何程序之前，您必须了解它们。如果您只是包含一个头文件，并使用该头文件中的一些函数或对象，那么当您试图编译程序时，您可能会得到听起来很奇怪的错误，结果是编译器无法找到您刚刚包含在头文件中的项的任何声明！看到这条消息几次后，你就会熟悉它的意思了(它是"*)你包含了头文件，但是所有的声明都在一个名称空间内，并且你没有告诉编译器你想使用那个名称空间中的声明。*”)。

有一个关键字允许你说“*我想在这个名称空间中使用声明和/或定义。*“这个关键词，再恰当不过了，就是`using`。所有的标准 C++ 库都封装在一个名称空间中，这个名称空间就是`std`(代表“标准”)。由于这本书几乎只使用标准库，你会看到下面的*在几乎每个程序中使用指令*:

```cpp
using namespace std;
```

这意味着您想要公开名为`std`的名称空间中的所有元素。在这个语句之后，您不必担心您的特定库组件在一个名称空间内，因为`using`指令使得这个名称空间在编写了`using`指令的整个文件中都可用。

在某人费尽心思隐藏元素之后，公开名称空间中的所有元素可能看起来有点适得其反，事实上，您应该小心不加思考地这样做(您将在本书后面了解到)。然而，`using`指令只公开了当前文件的那些名称，所以它并不像听起来那么激烈。(*但是在头文件中这样做要三思——那是鲁莽的。*

名称空间和头文件的包含方式有关系。在现代头文件包含被标准化之前(没有尾随的`.h`，如在`<iostream>`中)，包含头文件的典型方式是使用`.h`，如`<iostream.h>`。那时，名称空间也不是语言的一部分。所以为了提供与现有代码的向后兼容性，如果你说

```cpp
#include <iostream.h>
```

这意味着

```cpp
#include <iostream>
using namespace std;
```

然而，在本书中，将使用标准的 include 格式(没有`.h`)，因此`using`指令必须是明确的。

现在，这就是你需要知道的关于名称空间的全部内容，但是在第 10 章 的 *[中，这个主题被更彻底地讨论了。](10.html)*

程序结构基础

C T2 或 C++ 程序是变量、函数定义和函数调用的集合。当程序启动时，它执行初始化代码并调用一个特殊函数`main( )`。你把程序的主要代码放在这里。

如前所述，函数定义由返回类型(在 C++ 中必须指定)、函数名、圆括号中的参数列表和大括号中包含的函数代码组成。下面是一个函数定义示例:

```cpp
int function() {
  // Function code here (this is a comment)
}
```

这个函数有一个空的参数列表和一个只包含注释的函数体。

一个函数定义中可以有多组大括号，但函数体周围必须至少有一组大括号。由于`main( )`是一个函数，它必须遵循这些规则。在 C++ 中，`main( )`的返回类型总是为`int`。

*C* 和 C++ 是自由格式语言。除了少数例外，编译器会忽略换行符和空白，所以它必须有某种方法来确定语句的结尾。语句用分号分隔。

*C* 评论以`/*`开始，以`*/`结束。它们可以包括换行符。C++ 使用 C 风格的注释，并有一个额外的注释类型:`//`。`//`开始一个以换行符结束的注释。对于单行注释来说，它比`/* */`更方便，在本书中被广泛使用。

“你好，世界！”

现在，最后，第一个节目。见[清单 2-2](#list2) ！

***[清单 2-2](#_list2)*** 。你好，世界！

```cpp
//: C02:Hello.cpp
// Saying Hello with C++
#include <iostream> // Stream declarations
using namespace std;

int main() {
  cout << "Hello, World! I am "
       << 8 << " Today!" << endl;
} ///:∼
```

通过`<<`操作符向`cout`对象传递一系列参数。它按从左到右的顺序打印出这些参数。特殊的 iostream 函数`endl`输出一行和一个换行符。使用`iostream`，您可以像这样将一系列参数串在一起，这使得该类易于使用。

在 *C* 中，双引号内的文本传统上被称为*字符串*。然而，标准 C++ 库有一个强大的类叫做`string`用于操作文本，所以我将使用更精确的术语“*字符数组*来表示双引号内的文本。

编译器为字符数组创建存储区，并将每个字符的等效 ASCII 码存储在该存储区中。编译器自动终止这个字符数组，用一个包含值 0 的额外存储来指示字符数组的结尾。

在字符数组中，你可以使用*转义序列*来插入特殊字符。它们由一个反斜杠(`\`)后跟一个特殊代码组成。例如`\n`表示换行符。你的编译器手册或本地指南给出了完整的转义序列；其他还有`\t` (tab)、`\\`(反斜杠)、`\b`(退格)。

请注意，该语句可以在多行中继续，并且整个语句以分号结束。

在上面的`cout`语句中，字符数组参数和常量混合在一起。因为操作符`<<`在与`cout`一起使用时有多种含义，所以你可以向`cout`发送各种不同的参数，它会计算出如何处理消息。

在本书中，你会注意到每个文件的第一行都是一个注释，以开始注释的字符(通常是`//`)开头，后面跟着一个冒号，清单的最后一行以注释结尾，后面跟着`/:∼`。这是一种我们用来从代码文件中轻松提取信息的技术。第一行还有文件的名称和位置，因此可以在文本和其他文件中引用它。

运行编译器

下载并解包了书的源代码后，在子目录`CO2`中找到程序。使用`Hello.cpp`作为参数调用编译器。对于像这样简单的单文件程序，大多数编译器会带你完成整个过程。例如，要使用 GNU C++ 编译器(可以在网上免费获得)，你可以写

```cpp
g++ Hello.cpp
```

其他编译器也有类似的语法；有关详细信息，请参考编译器文档。

关于 iostream 的更多信息

到目前为止，您只看到了`iostream`类的最基本的方面。(关于`iostream`的详细讨论已延至 *[第 19 章](19.html)* )。`iostream`提供的输出格式还包括十进制、八进制和十六进制的数字格式。[清单 2-3](#list3) 显示了使用`iostream`的另一个例子。

***[清单 2-3](#_list3)*** 。iostream 的另一种用途

```cpp
//: C02:Stream2.cpp
// Demonstrates more streams features
#include <iostream>
using namespace std;

int main() {
  // Specifying formats with manipulators:
  cout << "a number in decimal: "
       << dec << 15 << endl;
  cout << "in octal: " << oct << 15 << endl;
  cout << "in hex: " << hex << 15 << endl;
  cout << "a floating-point number: "
       << 3.14159 << endl;
  cout << "non-printing char (escape): "
       << char(27) << endl;
} ///:∼
```

![image](img/sq.jpg) **注** *文档注释*///:∨——这是*在全书中重复*表示*结束的代码*。你会在第 18 章 (在“字符串应用”一节)中找到更多关于它的信息。

这个例子显示了`iostream`类使用 `iostream` *操纵器* ( *不打印任何东西，但是改变输出流的状态*)以十进制、八进制和十六进制打印数字。浮点数的格式由编译器自动确定。此外，可以使用*将*转换为`char`将任何字符发送给流对象(一个`char` *是保存单个字符*的数据类型)。这个*造型*看起来像一个函数调用`char( )`，还有角色的 ASCII 值。在[清单 2-3](#list3) 的程序中，`char(27)`向`cout`发送一个“escape”。

字符数组串联

*C* 预处理器的一个重要特性是*字符数组串联*。本书中的一些例子使用了这个特性。如果两个带引号的字符数组是相邻的，并且它们之间没有标点符号，编译器会将这些字符数组粘贴到一个字符数组中。这在代码清单有宽度限制时特别有用，如[清单 2-4](#list4) 。

***[清单 2-4](#_list4)*** 。字符数组串联

```cpp
//: C02:Concat.cpp
// Demonstrates special use of Character array Concatenation
// in case of coding with width restrictions
#include <iostream>
using namespace std;

int main() {
  cout << "This is far too long to put on a "
    "single line but it can be broken up with "
    "no ill effects\as long as there is no "
    "punctuation separating adjacent character "
    "arrays.\n";
} ///:∼
```

起初，清单 2-4 中的代码看起来像一个错误，因为在每一行的末尾没有熟悉的分号。记住 *C* 和 C++ 是自由格式语言；虽然您通常会在每一行的末尾看到一个分号，但实际要求是在每一条语句的末尾都有一个分号，而且一条语句可能会延续几行。

读取输入

`iostream`类提供了读取输入的能力。用于标准输入的对象是`cin` ( *为*“控制台输入”)。`cin`通常期望来自控制台的输入，但是这个输入可以从其他来源重定向。本章稍后将展示重定向的一个示例。

与`cin`一起使用的 iostreams 运算符是`>>`。该操作符等待与其参数相同的输入。例如，如果您给它一个整数参数，它将等待来自控制台的整数。[清单 2-5](#list5) 显示了一个例子。

***[清单 2-5](#_list5)*** 。阅读输入

```cpp
//: C02:Numconv.cpp
// Converts decimal to octal and hex
// Demonstrates use of cin operator
#include <iostream>
using namespace std;

int main() {
  int number;
  cout << "Enter a decimal number: ";
  cin >> number;
  cout << "value in octal = 0"
       << oct << number << endl;
  cout << "value in hex = 0x"
       << hex << number << endl;
} ///:∼
```

这个程序将用户输入的数字转换成八进制和十六进制。

调用其他程序

虽然使用从标准输入读取并写入标准输出的程序的典型方式是在 Unix shell 脚本或 DOS 批处理文件中，但是任何程序都可以使用标准的*C*T0】函数从 *C* 或 C++ 程序中调用，该函数在头文件`<cstdlib>`中声明，如清单 2-6 中的[所示。](#list6)

***[清单 2-6](#_list6)*** 。调用其他程序

```cpp
//: C02:CallHello.cpp
// Call another program
#include <cstdlib> // Declare "system()"
using namespace std;

int main() {
  system("Hello");
} ///:∼
```

要使用`system( )`函数，您需要给它一个字符数组，您通常会在操作系统命令提示符下输入这个数组。这也可以包括命令行参数，字符数组可以是你在运行时编造的(而不是像清单 2-6 所示的那样只使用静态字符数组)。命令执行，控制返回到程序。

这个程序展示了在 C++ 中使用普通的 *C* 库函数是多么容易:只需包含头文件并调用函数。如果你是从有 to C 语言背景的人开始学习这门语言，那么从 to C 语言到 C++ 的这种向上兼容性是一个很大的优势。

介绍字符串

虽然字符数组非常有用，但它非常有限。它只是内存中的一组字符，但是如果你想用它做任何事情，你必须管理所有的小细节。例如，带引号的字符数组的大小在编译时是固定的。如果你有一个字符数组，并且你想向它添加更多的字符，你需要理解很多东西(包括动态内存管理、字符数组复制和连接)才能实现你的愿望。这正是我们想让一个物体为我们做的事情。

标准的 C++ `string`类被设计用来处理(并隐藏)所有字符数组的低级操作，这些操作以前需要 C*C*程序员来完成。自从 *C* 语言出现以来，这些操作一直是浪费时间和错误的根源。因此，尽管在本书的后面有整整一章是专门讨论`string`类的，但是`string`是如此重要，它使生活变得如此简单，所以它将在这里被介绍，并在本书的大部分早期被使用。

要使用`string` s，您需要包含 C++ 头文件`<string>`。`string`类位于名称空间`std`中，因此需要一个`using`指令。因为操作符重载，使用`string` s 的语法非常直观，正如你在[清单 2-7](#list7) 中看到的。

***[清单 2-7](#_list7)*** 。使用字符串

```cpp
//: C02:HelloStrings.cpp
//  Demonstrates the basics of the C++ string class
#include <string>
#include <iostream>
using namespace std;

int main() {
  string s1, s2;               // Empty strings
  string s3 = "Hello, World."; // Initialized
  string s4("I am");           // Also initialized
  s2 = "Today";                // Assigning to a string
  s1 = s3 + " " + s4;          // Combining strings
  s1 += " 8 ";                 // Appending to a string
  cout << s1 + s2 + "!" << endl;
} ///:∼
```

前两个`string`、`s1`和`s2`开始时是空的，而`s3`和`s4`展示了从字符数组初始化`string`对象的两种等价方式(你可以同样容易地从其他`string`对象初始化`string`对象)。

您可以使用`=`分配给任何`string`对象。这会用右边的内容替换字符串中以前的内容，您不必担心以前的内容会发生什么——这是自动为您处理的。要组合`string` s，您只需使用`+`操作符，这也允许您将字符数组与`string` s 组合起来。如果您想要将`string`或字符数组附加到另一个`string`上，您可以使用操作符`+=`。最后，注意`iostream`已经知道如何处理`string` s，所以你可以直接向`cout`发送一个`string`(或者一个产生`string`的表达式，这发生在`s1 + s2 + "!"`中)来打印它。

读写文件

在 *C* 中，打开和操作文件的过程需要大量的语言背景知识，让你为操作的复杂性做好准备。然而，C++ `iostream`库提供了一种简单的方法来操作文件，因此这种功能可以比在 *C* 中更早地引入。

要打开文件进行读写，必须包含`<fstream>`。虽然这将自动包含`<iostream>`，但是如果您计划使用`cin`、`cout`等，显式包含`<iostream>`通常是谨慎的。

要打开一个文件进行读取，您需要创建一个`ifstream`对象，它的行为类似于`cin`。要打开一个文件进行写入，您需要创建一个`ofstream`对象，它的行为类似于`cout`。一旦你打开了这个文件，你就可以像对待任何其他`iostream`对象一样读取或写入它。就这么简单(当然，这就是重点)。

`iostream`库中最有用的函数之一是`getline( )`，它允许你将一行(以换行符结束)读入一个`string`对象。第一个参数是您正在读取的`ifstream`对象，第二个参数是`string`对象。当函数调用结束时，`string`对象将包含该行。清单 2-8 包含一个简单的例子，它将一个文件的内容复制到另一个文件中。

***[清单 2-8](#_list8)*** 。将一个文件复制到另一个文件，一次一行

```cpp
//: C02:Scopy.cpp
//  Demonstrates use of the getline() function
#include <string>
#include <fstream>
using namespace std;

int main() {
  ifstream in("Scopy.cpp");   // Open for reading
  ofstream out("Scopy2.cpp"); // Open for writing
  string s;
  while(getline(in, s))       // Discards newline char
    cout << s << "\n";        // ... must add it back
} ///:∼
```

要打开文件，你只需给`ifstream`和`ofstream`对象你想要创建的文件名，如[清单 2-8](#list8) 所示。

这里引入了一个新概念，就是`while`循环。虽然这将在下一章详细解释，但基本思想是`while`后面括号中的表达式控制后续语句的执行(也可以是多个语句，用花括号括起来)。只要括号中的表达式(在本例中是`getline(in, s)`)产生“真”结果，那么由`while`控制的语句将继续执行。原来，`getline( )`将返回一个值，如果另一行被成功读取，该值可以被解释为“真”，当到达输入的末尾时，该值为“假”。因此，上面的`while`循环读取输入文件中的每一行，并将每一行发送到输出文件。

`getline( )`读入每一行的字符，直到它发现一个新行(终止字符可以改变，但这不会成为问题，直到 *[第 19 章](19.html)* 关于 iostreams)。然而，它丢弃了换行符，并且没有将它存储在结果`string`对象中。因此，如果您希望复制的文件看起来像源文件一样，您必须重新添加换行符，如下所示。

另一个有趣的例子是将整个文件复制到一个单独的`string`对象中，如[清单 2-9](#list9) 所示。

***[清单 2-9](#_list9)*** 。将整个文件读入单个字符串

```cpp
//: C02:FillString.cpp
//   Demonstrates use of fstream
#include <string>
#include <iostream>
#include <fstream>
using namespace std;

int main() {
  ifstream in("FillString.cpp");
  string s, line;
  while(getline(in, line))
    s += line + "\n";
  cout << s;
} ///:∼
```

由于`string` s 的动态特性，你不必担心为一个`string`分配多少存储空间；你可以不断添加东西，而`string`会不断扩大，以容纳你放入的任何东西。

将整个文件放入一个`string`中的一个好处是，`string`类有许多搜索和操作功能，允许您将文件作为单个字符串进行修改。然而，这有其局限性。首先，将文件视为行的集合而不仅仅是一大块文本通常很方便。例如，如果你想添加行号，如果你把每一行作为一个单独的`string`对象，那就简单多了。要实现这一点，您需要另一种方法。

引入向量

使用`string` s，你可以填充一个`string`对象，而不知道你将需要多少存储空间。将文件中的行读入单个`string`对象的问题是，你不知道你将需要多少个`string`;你只有在阅读了整个文件后才知道。为了解决这个问题，你需要一种可以自动膨胀的支架，你想放多少`string`物品就放多少。

其实，为什么要把自己局限在拿着`string`物体呢？事实证明，这种问题——在你写程序的时候不知道你有多少东西——经常发生。这个“容器”对象听起来更有用，如果它能容纳任何种类的对象的话！幸运的是，标准 C++ 库有一个现成的解决方案:标准容器类。容器类是标准 C++ 的真正动力之一。

在标准 C++ 库中的容器和算法与被称为 STL 的实体之间经常会有一点混淆。STL 在许多细微之处与标准 C++ 库不同。所以，尽管这是一个普遍的误解，C++ 标准并没有“包括”STL。这可能有点令人困惑，因为标准 C++ 库中的容器和算法与 SGI STL 有相同的根(通常是相同的名称)。在本书中，我会说“标准 C++ 库”或“标准库容器”或类似的东西，我会避免使用“STL”这个术语。

标准库是如此的有用，以至于最基本的标准容器`vector`在这一章中被介绍，并在整本书中被使用。你会发现，仅仅通过使用`vector`的基础知识，而不用担心底层的实现(*，OOP* 的一个重要目标)，你就可以做很多事情。你会发现在大多数情况下，这里显示的用法是足够的。

*`vector`*类是一个模板*，这意味着它可以高效地应用于不同的类型。也就是你可以创建一个`shape` s 的`vector`，一个`cat` s 的`vector`，一个`string` s 的`vector`等等。基本上，用一个模板你可以创建一个“任何东西的类”为了告诉编译器这个类将处理什么(在这种情况下，`vector`将保存什么)，您将所需类型的名称放在尖括号中，这意味着<和>。因此`string`中的一个`vector`将被表示为`vector<string>`。当你这样做时，你最终得到一个定制的向量，它将只保存`string`对象，如果你试图把任何东西放入其中，你将从编译器得到一个错误消息。*

 *既然`vector`表达了容器的概念，那就一定有办法把东西放进容器，又把东西从容器里取出来。要在一个`vector`的末尾添加一个全新的元素，你可以使用成员函数`push_back( ).` ( *记住，因为它是一个成员函数，所以你可以使用一个“* `.` *”来调用它的一个特定对象*。)这个成员函数的名字可能看起来有点冗长(如在`push_back( )`中，而不是像“put”这样简单的东西)，因为有其他容器和其他成员函数可以将新的元素放入容器中。比如有一个`insert( )`成员函数把东西放在容器中间。`vector`支持这一点，但它的使用要复杂得多，我们在此不再深入探讨。还有一个`push_front( )`(不是`vector`的一部分)把事情放在开头。在`vector`中有更多的成员函数，在标准 C++ 库中有更多的容器，但是你会惊讶于仅仅了解一些简单的特性就能做这么多事情。

所以你可以用`push_back( )`把新元素放入`vector`中，但是你如何把这些元素取出来呢？这个解决方案更加巧妙和优雅。运算符重载用于使`vector`看起来像一个*数组*。数组(将在下一章更全面地描述)是一种几乎在每种编程语言中都可用的数据类型，所以您应该已经对它有些熟悉了。数组是*集合*，这意味着它们由许多聚集在一起的元素组成。数组的显著特征是这些元素大小相同，并且一个接一个地排列。最重要的是，这些元素可以通过*索引*来选择，这意味着你可以说*“我想要元素号 n”*然后那个元素就会产生，通常很快。虽然编程语言中也有例外，但索引通常是使用方括号来实现的，所以如果你有一个数组`a`并且你想产生元素五，你就说`a[4]`(注意*索引总是从零开始*)。

这种非常紧凑和强大的索引符号使用操作符重载合并到`vector`中，就像`<<`和`>>`合并到`iostream`中一样。同样，你不需要知道重载是如何实现的(这个留到后面的章节)，但是如果你知道为了让`[ ]`和`vector`一起工作，在幕后有一些魔术在进行，这是很有帮助的。

记住这一点，现在您可以看到一个使用`vector`的程序。要使用一个`vector`，你需要包含头文件`<vector>`，如[清单 2-10](#list10) 所示。

***[清单 2-10](#_list10)*** 。使用向量//: C02:Fillvector.cpp

```cpp
// Demonstrates copying an entire file into a vector of string #include <string>
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;

int main() {
  vector <string> v;
  ifstream in("Fillvector.cpp");
  string line;
  while(getline(in, line))
    v.push_back(line); // Add the line to the end
  // Add line numbers:
  for(int i = 0; i < v.size(); i++)
    cout << i << ": " << v[i] << endl;
} ///:∼
```

这个程序的大部分与前一个相似；打开一个文件，一次一行地读入`string`对象。然而，这些`string`物体被推到了`vector v`的背面。一旦`while`循环完成，整个文件就驻留在`v`内部的内存中。

程序中的下一条语句叫做`for`循环。它类似于`while`循环，只是增加了一些额外的控制。在`for`之后，括号内有一个“控制表达式”，就像`while`循环一样。然而，这个控制表达式由三部分组成:一部分初始化，一部分测试是否应该退出循环，另一部分改变一些东西，通常是遍历一系列项目。这个程序以最常用的方式展示了`for`循环:初始化部分`inti = 0`创建一个整数`i`作为循环计数器，并赋予其初始值 0。测试部分说，为了保持在循环中，`i`应该小于`vector v`中的元素数量。(这是使用成员函数`size( ),`生成的，这个函数在这里只是被偷偷放进去的，但是你必须承认它有一个相当明显的含义。)最后一部分使用了 *C* 和 C++ 的简写，即“自动递增”运算符，将`i`的值加 1。实际上，`i++`表示“获取`i`的值，加 1，并将结果放回`i`。因此，`for`循环的总体效果是获取一个变量`i`，并使其遍历从 0 到比`vector`小 1 的值。对于`i`的每个值，执行`cout`语句，这构建了一行，该行由`i`的值(被`cout`神奇地转换成一个字符数组)、一个冒号和一个空格、文件中的行以及由`endl`提供的换行符组成。当您编译并运行它时，您会看到结果是向文件中添加了行号。

由于`>>`操作符与`iostream`一起工作的方式，你可以很容易地修改[清单 2-10](#list10) 中的程序，使它将输入分成空格分隔的单词而不是行，如[清单 2-11](#list11) 所示。

***[清单 2-11](#_list11)*** 。将文件分解成空格分隔的单词

```cpp
//: C02:GetWords.cpp
// Modifies program in Listing 2-10
#include <string>
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;

int main() {
  vector<string> words;
  ifstream in("GetWords.cpp");
  string word;
  while(in >> word)
    words.push_back(word);
  for(int i = 0; i < words.size(); i++)
    cout << words[i] << endl;
} ///:∼
```

表情

```cpp
while(in >> word)
```

一次获取一个“单词”的输入，当该表达式的计算结果为“false”时，意味着已经到达了文件的末尾。当然，用空格分隔单词是相当粗糙的，但是这是一个简单的例子。在本书的后面，你会看到更复杂的例子，让你以任何你喜欢的方式分解输入。

为了演示使用任何类型的`vector`是多么容易，[清单 2-12](#list12) 展示了一个创建`vector<int>`的例子。

***[清单 2-12](#_list12)*** 。使用任何类型的向量

```cpp
//: C02:Intvector.cpp
// Demonstrates creation of a vector that holds integers
#include <iostream>
#include <vector>
using namespace std;

int main() {
  vector<int> v;
  for(int i = 0; i < 10; i++)
    v.push_back(i);
  for(int i = 0; i < v.size(); i++)
    cout << v[i] << ", ";
  cout << endl;
  for(int i = 0; i < v.size(); i++)
    v[i] = v[i] * 10; // Assignment
  for(int i = 0; i < v.size(); i++)
    cout << v[i] << ", ";
  cout << endl;
} ///:∼
```

要创建一个保存不同类型的`vector`，只需将该类型作为模板参数放入即可(*尖括号中的参数*)。模板和设计良好的模板库就是为了这么容易使用。

这个例子继续展示了`vector`的另一个基本特性。在表达式中

```cpp
v[i] = v[i] * 10;
```

你可以看到`vector`并不仅限于放入和取出东西。您还可以通过使用方括号索引操作符将(从而改变)分配给`vector`的任何元素。这意味着`vector`是一个通用的、灵活的便笺式存储器，用于处理对象集合。在接下来的章节中，你肯定会用到它。

审查会议

1.  本章的目的是向您展示面向对象编程是多么容易——如果有人已经为您定义了对象的话。在这种情况下，您包括一个头文件，创建对象，并向它们发送消息。如果你正在使用的类型是强大的和设计良好的，那么你将不必做很多工作，你的结果程序也将是强大的。
2.  在展示使用库类时`OOP`的简易性的过程中，本章还介绍了*标准 C++ 库*中一些最基本和最有用的类型:`iostream`族(特别是*，那些从控制台和文件*中读取和写入的类型、`string`类和`vector`模板。您已经看到了使用这些类型是多么简单，现在可能可以想象用它们可以完成许多事情，但是实际上它们可以做的事情还很多。
3.  尽管在本书的早期你只会使用这些工具功能的有限子集，但它们仍然比学习像`C` *这样的低级语言的原始水平提高了一大步。*虽然学习`C`的低级方面很有教育意义，但也很耗时。最后，如果你有对象来管理底层问题，你会更有效率。毕竟，OOP 的整个*点*就是隐藏细节，这样你就可以“用更大的画笔绘画”
4.  然而，尽管 OOP 很高级，但 C 的一些基本方面是你无法避免知道的，这些将在下一章讨论。**