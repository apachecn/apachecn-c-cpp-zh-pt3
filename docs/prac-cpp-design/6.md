# 6.图形用户界面

在本章中，我们将探索 pdCalc 的图形用户界面(GUI)的设计。任何时候设计一个 GUI，都需要选择一个窗口小部件平台。如前所述，我选择使用 Qt 来创建 GUI。也就是说，这不是一个如何使用 Qt 设计界面的章节。相反，我假设读者有 Qt 的工作知识，并且这一章本身集中在 GUI 的设计方面。事实上，我将尽可能地让读者阅读源代码来了解小部件实现的细节。任何关于 Qt 实现的讨论要么只是附带的，要么值得特别强调。如果你对图形用户界面设计不感兴趣，这一章可以完全跳过，几乎不会影响连贯性。

## 6.1 要求

在第 [5](5.html) 章中，我们开始了对命令行界面(CLI)的分析，导出了一个可供 CLI 和 GUI 使用的接口抽象。显然，我们将在这里重用这个接口，因此我们已经知道了我们的整个用户界面必须符合的抽象接口。因此，我们从定义 GUI 专门化的要求开始这一章。

和 CLI 一样，我们很快发现第 [1](1.html) 章的要求对于指定一个图形用户界面来说是远远不够的。给定的要求只是功能性的。也就是说，我们知道计算器应该支持哪些按钮和操作，但我们对预期的外观一无所知。

在一个商业项目中，人们会(希望)让客户、图形艺术家和用户体验专家来协助设计 GUI。对于我们的案例研究，充分说明我们自己的要求就足够了:

1.  GUI 应该有一个显示输入和输出的窗口。输出是当前堆栈的前六个条目。

2.  GUI 应该有可点击的按钮来输入数字和所有支持的命令。

3.  GUI 应该有一个显示错误消息的状态显示区域。

前面的要求仍然没有解释计算器实际上应该是什么样子。为此，我们需要一张照片。图 [6-1](#Fig1) 显示了在我的 Windows 桌面上出现的工作计算器(使用 Qt 5.15.2 的 Windows 10)。将完成的图形用户界面作为设计图形用户界面的原型展示无疑是“欺骗”希望这条捷径不会太偏离案例研究的真实性。显然，在开发的这个阶段不会有成品。在生产环境中，人们可能会用手或用 Microsoft PowerPoint、Adobe Illustrator 或 Inkscape 等程序绘制模型。或者，也许 GUI 是从一个物理对象建模的，设计者要么有照片，要么直接访问那个对象。例如，一个人可能正在设计一个 GUI 来代替一个物理控制系统，并且需求指定界面必须显示相同的刻度盘和仪表(以减少操作员再培训的成本)。

![../images/454125_2_En_6_Chapter/454125_2_En_6_Fig1_HTML.png](../images/454125_2_En_6_Chapter/454125_2_En_6_Fig1_HTML.png)

图 6-1

没有插件的 Windows 上的 GUI

pdCalc 的 GUI 灵感来自我的 HP48S 计算器。对于那些熟悉本系列中任何一款惠普计算器的人来说，这个界面有些熟悉。对于那些不熟悉这一系列计算器的人(可能是大多数读者)，下面的描述解释了 GUI 的基本行为。

GUI 的顶部三分之一是专用的输入/输出(I/O)窗口。I/O 窗口在左侧显示前六个堆栈级别的标签，堆栈的顶部在窗口的底部。堆栈上的值出现在窗口右侧与数字在堆栈上的位置相对应的行上。当用户输入一个数字时，堆栈减少到只显示顶部的五个堆栈元素，而输入的数字在底部行左对齐显示。一个数字被终止，并通过按 enter 按钮输入到堆栈中。

假设有足够的输入，一按下按钮就开始操作。如果输入不足，I/O 窗口上方会显示一条错误消息。对于命令，输入区域中的有效数字被视为堆栈中的顶部数字。也就是说，在输入数字的同时应用操作相当于按下 enter 然后应用操作。

为了节省空间，一些按钮的操作被移到了按钮本身的上方和左侧。首先按下 shift 按钮，然后按下移位文本下方的按钮，可以激活这些移位操作。按下 shift 按钮会将计算器置于移位模式，直到按下具有移位操作的按钮或再次按下 shift 按钮。为了清楚起见，移位操作通常是按钮操作的逆操作。

为了方便输入，许多按钮被绑定到键盘快捷键。也就是说，除了按压 GUI 按钮之外，还可以替代地按压键盘按键。比如按相应的数字键可以点击数字按钮，按 Enter 键可以点击 Enter 键，按 S 键可以点击 Shift 键，按 Backspace 键可以点击 Bksp 键，按 E 键可以点击取幂运算(eex)，按相应的键盘键可以点击四则基本算术运算(+、-、*、/)。

最后，一些操作是半隐藏的。当不输入数字时，退格键从堆栈中删除顶部条目，而回车键复制堆栈中的顶部条目。这些组合中的一些并不直观，因此可能并不代表很好的 GUI 设计。但是，它们确实模拟了 HP48S 上使用的输入。如果您以前从未使用过 HP48 系列计算器，我强烈建议您在继续之前，从 GitHub 资源库构建并熟悉 GUI。

如果你想知道`proc`键是做什么的，它会执行存储过程。这是我们将在第 8 章中遇到的“新”需求之一。

人们对 GUI 的第一个批评可能是它不太漂亮。我同意。本章中 GUI 的目的不是演示高级 Qt 特性。相反，目的是说明如何设计模块化、健壮、可靠和可扩展的代码库。添加代码使 GUI 更有吸引力而不是功能性会分散对这个信息的注意力。当然，这个设计允许一个更漂亮的 GUI，所以你可以在提供的基础设施上随意制作你自己的漂亮 GUI。

我们现在有足够的细节来设计和实现计算器的 GUI。然而，在我们开始之前，有必要对构建 GUI 的替代方法进行一个简短的讨论。

## 6.2 构建 GUI

本质上，构建 GUI 有两种不同的途径:在集成开发环境(IDE)中构建 GUI，或者在代码中构建 GUI。在这里，我不严格地使用术语代码来表示通过文本构建 GUI，无论是使用传统的编程语言(如 C++)还是声明性的标记语法(如 XML)。当然，介于两个极端之间的是混合方法，它利用来自 ide 和代码的元素。

### 6.2.1 在 ide 中构建 GUI

如果您需要的只是一个简单的 GUI，那么，在 IDE 中设计和构建您的 GUI 无疑是更容易的途径。大多数 ide 都有一个图形界面，用于在画布上展示可视元素，例如，画布可能代表一个对话框或小部件。一旦建立了新的画布，用户就可以通过将现有的小部件拖放到画布上来可视化地构建 GUI。现有的窗口小部件包括 GUI 工具包的内置图形元素(例如，按钮)以及在 IDE 框架中支持拖放的自定义窗口小部件。一旦布局完成，就可以用图形或一点点代码将动作捆绑在一起。最后，IDE 会创建与图形化 GUI 相对应的代码，IDE 创建的代码会与其余的源代码一起编译。

使用 IDE 构建 GUI 既有优点也有缺点。一些优点如下。首先，因为这个过程是可视化的，所以在执行布局时，您可以很容易地看到 GUI 的外观。这与为 GUI 编写代码形成了鲜明的对比，在编写代码时，您只能看到编译和执行代码后的 GUI 外观。这种区别非常类似于使用微软 Word 这样的 WYSIWYG 文本编辑器和 LaTeX 这样的标记语言来写论文的区别。其次，IDE 通过在后台自动生成代码来工作，因此图形化方法可以显著减少编写 GUI 所需的编码量。第三，ide 通常在属性表中列出 GUI 元素的属性，这使得在不经常查阅 API 文档的情况下对 GUI 进行风格化变得很简单。这对于很少使用的功能尤其有用。

使用 IDE 构建 GUI 的一些缺点如下。首先，您受限于 IDE 选择公开的 API 子集。有时候，完整的 API 是公开的，有时候，不是。如果您需要 IDE 作者没有授予您的功能，您将被迫编写自己的代码。也就是说，IDE 可能会限制对 GUI 元素的微调控制。其次，对于重复的 GUI 元素，您可能需要多次执行相同的操作(例如，单击以使所有按钮中的文本变为红色)，而在代码中，很容易将任何重复的任务封装在类或函数调用中。第三，使用 IDE 设计 GUI 将 GUI 限制在可以在编译时做出的决定。如果你需要动态地改变一个 GUI 的结构，你需要为此写代码。第四，在 IDE 中设计 GUI 会将您的代码与特定的供应商产品联系起来。在公司环境中，这可能不是一个重要的问题，因为整个公司的开发环境可能是统一的。然而，对于一个开放源代码的分布式项目，并不是每个想为您的代码库做贡献的开发人员都希望被限制在您选择的 IDE 中。

### 6.2.2 用代码构建 GUI

顾名思义，用代码构建 GUI。您可以编写代码与 GUI 工具包进行交互，而不是以图形方式将小部件放在画布上。对于如何编写代码，有几种不同的选择，通常，对于任何给定的 GUI 工具包，都有不止一种选择。首先，您几乎总是可以用工具包的语言编写源代码。例如，在 Qt 中，您可以完全通过以命令式风格编写 C++来构建您的 GUI(即，您显式地指导 GUI 的行为)。其次，一些 GUI 工具包允许声明性风格(即，您编写描述 GUI 元素风格的标记代码，但是工具包定义元素的行为)。最后，一些工具包使用基于脚本的接口来构造 GUI(通常是 JavaScript 或 JavaScript 派生语法),可能与声明性标记结合使用。在本章的上下文中，用代码构建 GUI 专指用 C++针对 Qt 的桌面小部件集进行编码。

正如您所料，用代码构建 GUI 与用 IDE 构建 GUI 的权衡几乎相反。优点如下。首先，小部件的完整 API 是完全公开的。因此，程序员有尽可能多的微调控制。如果小部件库设计者希望用户能够做一些事情，你可以用代码来做。第二，通过使用抽象，重复的 GUI 元素很容易管理。例如，在设计计算器时，我们可以创建一个按钮类并简单地实例化它，而不必手动定制每个按钮。第三，在运行时动态添加小部件很容易。对于 pdCalc 来说，这个优势对于满足支持动态插件的需求非常重要。第四，如果构建系统独立于 IDE，那么用代码设计 GUI 就完全独立于 IDE。

虽然用代码构建 GUI 有很多优点，但也存在缺点。首先，布局不直观。为了看到 GUI 成形，您必须编译并执行代码。如果它看起来是错误的，你必须调整代码，再试一次，并重复这个过程，直到你得到它的权利。这可能是非常乏味和耗时的。其次，您必须自己编写所有代码。尽管 IDE 会自动生成 GUI 代码的很大一部分，尤其是与布局相关的部分，但是当您编写代码时，您必须手动完成所有工作。最后，当用代码编写 GUI 时，您将无法在属性表上简洁地访问小部件的所有属性。通常，您需要更频繁地查阅文档。也就是说，良好的 IDE 代码完成对这项任务有很大的帮助。有人可能会对我的最后一句话大呼冤枉，声称“使用 IDE 可以减轻不使用 IDE 的缺点是不公平的。”请记住，除非您是在纯文本编辑器中编写源代码(不太可能)，否则代码编辑器仍然可能是一个复杂的 IDE。我比较了使用 IDE 的图形 GUI 布局工具构建 GUI 和使用现代代码编辑器(可能本身就是 IDE)手动编写代码。

### 6.2.3 哪种 GUI 构建方法比较好？

对于标题中过于笼统的问题，答案当然是否定的。哪种技术更适合构建 GUI 完全取决于上下文。当您在自己的编码追求中遇到这个问题时，请参考前面的权衡，并根据您的情况做出最明智的选择。通常，最好的解决方案是一种混合策略，其中 GUI 的某些部分将以图形方式进行布局，而 GUI 的其他部分将完全由代码构建。

在我们的上下文中，一个更具体的问题是，“哪种 GUI 构建方法更适合 pdCalc？”对于这个应用程序，权衡的结果是更倾向于基于代码的方法。首先，计算器的可视化布局相当简单(一个状态窗口、一个显示部件和一个按钮网格)，很容易用代码实现。这一事实立即消除了 IDE 方法最显著的优势，即可视化地处理复杂的布局。第二，按钮的创建和布局是重复的，但是很容易封装，这是基于代码的方法的优点之一。最后，因为计算器必须支持运行时插件，所以代码方法更适合动态添加小部件元素(运行时发现的按钮)。

在本章的剩余部分，我们将探索 PD calc GUI 的代码设计。特别是，重点将放在组件及其接口的设计上。因为我们的重点不是小部件的构造，所以许多实现细节将被忽略。然而，不要害怕。如果您对细节感兴趣，所有代码都可以在 GitHub 资源库中找到。

## 6.3 模块化

从本书开始，我们已经讨论了计算器的分解策略。使用 MVC 架构模式，我们将设计分成一个模型、一个视图和一个控制器。在第 4 章中，我们看到其中一个主要模块，命令调度程序，被分成了几个子组件。CLI 模块足够简单，可以用一个类来实现，而 GUI 模块足够复杂，因此分解非常有用。回想一下第 2 章[中的内容，当我们提到 GUI 模块时，我们只是将模块作为一个逻辑结构，因为在撰写本文时，Qt 还不支持 C++20 模块。](2.html)

在第 5 章中，我们决定我们系统的任何用户界面都必须继承`UserInterface`抽象类。本质上，`UserInterface`类定义了 MVC 模式中视图的抽象接口。虽然 GUI 模块必须从`UserInterface`继承，因此向控制器呈现相同的抽象接口，但是我们可以自由地分解 GUI 的内部，只要我们认为合适。我们将再次使用松耦合和强内聚的指导原则来模块化 GUI。

当我分解一个模块时，我首先考虑的是强内聚性。也就是说，我试图将模块分成小的组件，每个组件做一件事(并且做得很好)。让我们用 GUI 来尝试一下。首先，任何 Qt GUI 都必须有一个主窗口，通过继承`QMainWindow`来定义。主窗口也是 MVC 视图的入口点，所以我们的主窗口也必须从`UserInterface`继承。`MainWindow`是我们的第一堂课。接下来目测图 [6-1](#Fig1) ，计算器明显分为用于输入的组件(按钮集合)和用于显示的组件。因此，我们增加了两个等级:T3 和 T4。我们已经讨论过使用代码方法构建 GUI 的一个优点是抽象了按钮的重复创建，所以我们也将创建一个`CommandButton`类。最后，我添加了一个负责管理计算器外观的组件(例如，字体、边距、间距等)。)我恰当地将其命名为`LookAndFeel`类。还存在一个用于存储过程条目的组件，但是我们将把对该组件的讨论推迟到第 [8](8.html) 章。现在让我们看看每个类的设计，从`CommandButton`开始。我们将讨论对这个初始分解的任何必要的改进，如果它们出现的话。

### 6.3.1 命令按钮抽象

我们从描述按钮是如何被抽象的开始讨论。这是一个合理的起点，因为按钮是数字和命令输入到计算器的基础。

Qt 提供了一个按钮小部件类，它显示一个可点击的按钮，当按钮被点击时会发出一个信号。这个`QPushButton`类提供了数字和命令输入所需功能的基础。我们可以采用的一种预期设计是按原样使用`QPushButton` s。这种设计需要明确地编写代码，将每个`QPushButton`手动连接到它自己定制的插槽。然而，这种方法是重复的、乏味的，并且非常容易出错。此外，一些按钮需要`QPushButton` API 没有提供的附加功能(例如，移位输入)。因此，我们为我们的程序寻找一个按钮抽象，它建立在`QPushButton`之上，用额外的功能补充这个 Qt 类，但同时也限制`QPushButton`的接口以完全满足我们的需求。我们称这个类为`CommandButton`。

用模式的话来说，我们提出了既作为适配器又作为门面的东西。我们在第三章[中看到了适配器模式。门面模式是近亲。适配器模式负责将一个接口转换成另一个接口(可能经过一些调整)，而外观模式负责为子系统中的一组接口提供统一的接口(通常是一种简化)。我们的`CommandButton`肩负着这两项任务。我们都在将`QPushButton`接口简化为 pdCalc 需要的受限子集，同时调整`QPushButton`的功能以满足我们问题的需求。那么，`CommandButton`到底是门面还是适配器？区别是无关紧要的；它共享每一个的特征。请记住，理解不同模式的目标并根据您的需求调整它们是非常重要的。为了模式的纯粹性，不要迷失在四人帮[11]的机械实现中。](3.html)

#### CommandButton 设计

除了介绍性的评论，我们仍然必须确定我们的`CommandButton`到底需要做什么，以及它将如何与 GUI 的其余部分交互。在许多方面，`CommandButton`的外表和行为都与`QPushButton`相似。例如，`CommandButton`必须呈现一个可以点击的可视按钮，在按钮被点击后，它应该发出某种信号，让其他 GUI 组件知道发生了点击动作。然而，与标准的`QPushButton`不同，我们的`CommandButton`必须支持标准状态和移动状态(例如，一个支持 sin 和 arcsin 的按钮)。这种支持应该是可视化的(两种状态都应该由我们的`CommandButton`小部件显示)和功能性的(点击信号必须描述标准点击和移位点击)。因此，我们需要回答两个设计问题。首先，我们如何设计和实现小部件以正确地出现在屏幕上？第二，一般来说，计算器如何处理移位运算？

让我们首先解决`CommandButton`外观问题。当然，我们可以从头开始实现我们的按钮，手动绘制屏幕，并使用鼠标事件来捕获按钮点击，但这对`CommandButton`来说太过了。相反，我们寻求一个重用 Qt 的`QPushButton`类的解决方案。我们基本上有两种复用选择:继承和封装。

首先，让我们考虑通过继承在`CommandButton`类的设计中重用`QPushButton`类。这种方法是合理的，因为人们可以在逻辑上采用 a `CommandButton` *是-a* `QPushButton`的观点。然而，这种方法有一个直接的缺陷。一个 *is-a* 关系意味着公共继承，这意味着`QPushButton`的整个公共接口将成为`CommandButton`公共接口的一部分。然而，我们已经确定，为了简化 pdCalc，我们希望`CommandButton`有一个受限的接口(facade 模式)。好，让我们尝试私有继承，并将我们的观点修改为一个*实现——一个`CommandButton`和`QPushButton`之间的*关系。现在我们遇到了第二个缺陷。没有来自`QPushButton`的公共继承，`CommandButton`失去了对`QWidget`类的间接继承，这是 Qt 中一个类成为用户界面对象的先决条件。因此，任何私有继承`QPushButton`的实现也需要从`QWidget`进行公共继承。然而，因为`QPushButton`也继承自`QWidget`，所以`CommandButton`对这两个类的多重继承会导致歧义，因此是不允许的。我们必须寻找另一种设计。

现在，考虑将一个`QPushButton`封装在一个`CommandButton`中(即`CommandButton` *有一个* `QPushButton`)。我们可能应该从这个选项开始，因为一般的实践表明我们应该尽可能地选择封装而不是继承。然而，许多开发人员倾向于从继承开始，我想讨论这种方法的缺点，而不仅仅求助于 C++最佳实践标准。除了打破强继承关系之外，选择封装方法还克服了前面讨论的使用继承的两个缺点。首先，由于`QPushButton`将被封装在`CommandButton`中，我们可以自由地只暴露`QPushButton`接口中对我们的应用程序有意义的那些部分(或者根本没有)。其次，通过使用封装，我们将避免同时从`QWidget`和`QPushButton`类继承的多重继承混乱。注意，原则上我不反对使用多重继承的设计。在这种情况下，多重继承是不明确的。

封装关系可以采用组合或聚合的形式。`CommandButton`类哪个合适？考虑两个类，`A`和`B`，其中`A`封装了`B`。在复合关系中，`B`是`A`的组成部分。在代码中，这种关系表示如下:

```
class A
{
  // ...
private:
  B b_;
};

```

相反，聚合意味着`A`只是在内部使用一个`B`对象。在代码中，聚合表示如下:

```
class A
{
  // ...
private:
  B* b_; // or some suitable smart pointer or reference
};

```

对于我们的应用程序，我认为聚合更有意义。也就是说，我们的`CommandButton`使用了一个`QPushButton`，而不是由一个`QPushButton`组成。这种差别是微妙的，同样合乎逻辑的论点可以用来声明这种关系是复合的。也就是说，两种设计都在 Qt 中机械地工作，所以你的编译器不会在乎你选择如何表达这种关系。

既然我们已经决定在`CommandButton`中聚合`QPushButton`，我们可以继续进行`CommandButton`类的总体设计。我们的`CommandButton`必须同时支持主命令和辅助命令。视觉上，我选择在按钮上显示主要命令，在按钮的左上方用蓝色显示辅助命令(我们将讨论如何暂时改变状态)。因此，`CommandButton`仅仅实例化了一个`QPushButton`和一个`QLabel`，并将它们都放在一个`QVBoxLayout`中。`QPushButton`显示主命令的文本，`QLabel`显示移位命令的文本。布局如图 [6-2](#Fig2) 所示。如前所述，为了完成设计，为了与 GUI 的其余部分进行图形交互，`CommandButton`必须公开继承`QWidget`类。该设计产生了一个可重用的`CommandButton`小部件类，用于声明主要和次要命令的通用按钮。因为按钮动作是通过使用`QPushButton`实现的，所以`CommandButton`类的整体实现非常简单。

重用`QPushButton`还有最后一个小细节。显然，由于`QPushButton`被私有地封装在`CommandButton`中，客户端无法从外部连接到`QPushButton`的`clicked()`信号，这使得客户端代码无法知道何时点击了`CommandButton`。这个设计其实是有意的。`CommandButton`将在内部捕获`QPushButton`的`clicked()`信号，随后重新发射自己的信号。这个公共`CommandButton`信号的设计与移位状态的处理有着错综复杂的联系。

![../images/454125_2_En_6_Chapter/454125_2_En_6_Fig2_HTML.png](../images/454125_2_En_6_Chapter/454125_2_En_6_Fig2_HTML.png)

图 6-2

`CommandButton`的布局

我们现在返回到对计算器内的移位状态进行建模。我们有两个实际的选择。第一个选项是让`CommandButton` s 了解计算器何时处于移位状态，并且只发出正确的移位或未移位命令。或者，第二个选项是让`CommandButton`的信号同时包含移位和未移位命令，并让信号接收器整理出计算器的当前状态。让我们检查这两个选项。

第一个选项，让`CommandButton` s 知道计算器是处于移位状态还是非移位状态，实现起来相当容易。在一个实现中，当按下换档按钮时，换档按钮通知每个按钮(通过 Qt 信号和槽)，并且按钮在换档和非换档状态之间切换。如果需要，甚至可以在每次切换转换状态时，将转换位置的文本与按钮上的文本进行交换。或者，切换按钮可以连接到一个设置全局切换状态标志的插槽，当按钮发出发生点击的信号时，按钮可以查询该标志。在任一实现场景中，当单击按钮时，只发出当前状态的命令，该命令的接收者最终通过一个`commandEntered()`事件将该命令从 GUI 中转发出去。

在第二个选项中，`CommandButton`不需要知道计算器的任何状态。相反，当一个按钮被点击时，它会以移动和非移动两种状态发出信号。本质上，按钮只是在被单击时通知它的侦听器，并提供两种可能的命令。然后，接收器负责确定在`commandEntered()`事件中发出哪些可能的命令。接收方大概必须负责跟踪移位的状态(或者能够轮询持有该状态的另一个类或变量)。

对于`CommandButton`，处理计算器状态的两种设计都相当不错。然而，就个人而言，我更喜欢不需要`CommandButton` s 知道任何关于转移状态的设计。在我看来，这种设计促进了更好的内聚性和更松散的耦合。这个设计更有凝聚力，因为`CommandButton`应该负责显示一个可点击的小部件，并在按钮被点击时通知系统。要求`CommandButton`理解计算器状态侵犯了它们抽象的独立性。这些按钮不再是带有两个命令的普通可点击按钮，而是与计算器的全局状态概念紧密联系在一起。此外，通过迫使`CommandButton` s 理解计算器的状态，通过迫使`CommandButton` s 不必要地互连到移位按钮或它们必须轮询的类，增加了系统中的耦合。当 shift 按钮被按下时，通知每一个`CommandButton`的唯一好处是能够交换主要和次要命令的标签。当然，标签交换可以独立于`CommandButton`的信号参数来实现。

#### CommandButton 界面

获得正确的设计是困难的部分。有了设计，界面实际上就可以自己写了。让我们检查一下`CommandButton`类定义的简化版本:

```
class CommandButton : public QWidget
{
  Q_OBJECT // needed by all Qt objects with signals and slots
public:
  CommandButton(const string& dispPrimaryCmd, const string& primaryCmd,
    const string& dispShftCmd, const string& shftCmd,
    QWidget* parent = nullptr);

  CommandButton(const string& dispPrimaryCmd, const string& primaryCmd,
    QWidget* parent = nullptr);

private slots:
  void onClicked();

signals:
  void clicked(string primCmd, string shftCmd);
};

```

`CommandButton`类有两个构造函数:四参数重载和两参数重载。四参数重载允许指定主要命令和辅助命令，而两参数重载只允许指定主要命令。每个命令都需要两个字符串来提供完整的说明。第一个字符串相当于标签将在 GUI 中显示的文本，可以在按钮上显示，也可以在移动后的命令位置显示。第二个字符串相当于由`commandEntered()`事件引发的文本命令。可以通过要求这两个字符串相同来简化接口。但是，我选择增加显示不同于命令调度程序所需的文本的灵活性。注意，由于尾部的`parent`指针，我们需要重载而不是默认参数。

该接口唯一的另一个公共部分是`clicked()`信号，它与按钮的主命令和移位命令一起发出。双变元对一变元信号背后的基本原理之前已经讨论过了。尽管是私有的，我还是在`CommandButton`的界面中列出了`onClicked()`插槽，以突出显示为了捕捉内部`QPushButton`的`clicked()`信号而必须创建的私有插槽。`onClicked()`函数的唯一目的是捕获`QPushButton`的`clicked()`信号，并发出带有两个函数参数的`CommandButton`的`clicked()`信号。

如果你看看`CommandButton.h`中`CommandButton`类的实际声明，你会看到一些额外的函数作为`CommandButton`公共接口的一部分。这些只是简单的转发功能，要么改变外观(例如，文本颜色)，要么向底层`QPushButton`添加可视元素(例如，工具提示)。虽然这些功能是`CommandButton`界面的一部分，但它们在功能上是可选的，并且独立于`CommandButton`的底层设计。

### 获取输入

GUI 需要接受两种不同类型的用户输入:数字和命令。这两种输入类型都是用户通过排列在网格中的`CommandButton`(或映射到这些按钮的键盘快捷键)输入的。这些`CommandButton`的集合、它们的布局以及它们给 GUI 其余部分的相关信号组成了`InputWidget`类。

命令输入在概念上很简单。点击一个`CommandButton`,然后发出一个信号，反映该特定按钮的命令。最终，GUI 的另一部分将接收这个信号，并引发一个由命令调度程序处理的`commandEntered()`事件。

输入数字比输入命令要复杂一些。在 CLI 中，我们可以简单地允许用户键入数字，并在输入完成后按 enter 键。然而，在 GUI 中，我们没有这样的内置机制(假设我们想要一个比 Qt 窗口中的 CLI 更复杂的 GUI)。虽然计算器确实有一个用于输入数字的`Command`，但请记住，它假设的是完整的数字，而不是单个数字。因此，GUI 必须有一个构造数字的机制。

构建数字包括输入数字和特殊符号，如小数点、加/减运算符或取幂运算符。此外，当用户输入时，他们可能会出错，所以我们也希望启用基本编辑(例如退格)。数字的组合是一个两步过程。`InputWidget`只负责发出编写和编辑数字所需的按钮点击。GUI 的另一部分将接收这些信号并汇编完整的数字输入。

#### 输入输出集的设计

从概念上讲，`InputWidget`类的设计很简单。小部件必须显示生成和编辑输入所需的按钮，将这些按钮绑定到按键(如果需要)，并在这些按钮被单击时发出信号。如前所述，`InputWidget`包含数字输入和命令输入按钮。因此，它负责数字 0 `–` 9、加号/减号按钮、小数点按钮、求幂按钮、回车按钮、退格按钮、shift 按钮以及每个命令的按钮。回想一下，作为一种节约，`CommandButton`类允许每个可视按钮有两个不同的命令。

为了整个 GUI 的一致性，我们将使用`CommandButton`专门作为所有输入按钮的表示，即使是既没有发布命令也没有辅助操作的按钮(例如 0 按钮)。我们对`CommandButton`的设计如此灵活，真是太方便了！然而，这个决定仍然给我们留下了两个突出的设计问题，即我们如何在视觉上布局按钮，以及当按钮被点击时我们该做什么。

在`InputWidget`中放置按钮有两种选择。首先，`InputWidget`本身拥有一个布局，它将所有的按钮放在这个内部布局中，然后`InputWidget`本身可以放在主窗口的某个地方。备选方案是`InputWidget`在建造期间接受外部拥有的布局，并将其`CommandButton`放置在该布局上。总的来说，让`InputWidget`拥有自己的布局是最好的设计。与替代方法相比，它提高了内聚力，减少了耦合。让`InputWidget`接受外部布局的唯一例外是，如果设计要求其他类共享相同的布局来放置额外的小部件。在这种特殊情况下，使用两个类外部拥有的共享布局会更简洁。

现在让我们把注意力转向点击`InputWidget`中的按钮会发生什么。因为`InputWidget`封装了`CommandButton` s，每个`CommandButton`的`clicked()`信号不能被`InputWidget`类的消费者直接访问。因此，`InputWidget`必须捕捉所有的`CommandButton`点击并重新发出。对于正弦或正切等计算器命令，重新发出单击是一个微不足道的转发命令。事实上，Qt 支持将`CommandButton`的`clicked()`信号直接连接到`InputWidget commandEntered()`信号的简写符号，无需通过`InputWidget`中的私有插槽。数字、数字编辑按钮(如加/减、退格)和计算器状态按钮(如 shift)通过在`InputWidget`的专用槽中捕捉来自`CommandButton`的特定`clicked()`信号并随后为这些动作中的每一个发出`InputWidget`信号来更好地处理。

如上所述，当按下每个输入按钮时，`InputWidget`必须发出自己的信号。在一个极端情况下，`InputWidget`可以为每个内部`CommandButton`提供单独的信号。在另一个极端，不管按钮按下与否，`InputWidget`只能发出一个信号，并通过一个参数来区分动作。正如所料，对于我们的设计，我们将寻求一些中间地带，分享来自每一个极端的元素。

本质上，`InputWidget`接受三种不同类型的输入:修饰符(例如，回车、退格、加/减、shift)、科学符号字符(例如，0 `–` 9、十进制、取幂)或命令(例如，正弦、余弦等)。).每个修改器需要一个唯一的响应；因此，每个修饰物结合到它自己单独的信号上。另一方面，科学符号字符可以简单地通过在屏幕上显示输入字符来统一处理(`Display`类的作用)。因此，科学符号字符都是通过发出一个信号来处理的，该信号将特定字符编码为一个参数。最后，通过发出单个信号来处理命令，该信号只是将主要和次要命令作为信号的函数参数一字不差地转发。

在构建信号处理时，重要的是将`InputWidget`作为一个类来维护，以便向 GUI 的其余部分发送原始用户输入信号。让`InputWidget`解释按钮按下会导致问题。例如，假设我们设计了`InputWidget`来聚合字符，并且只发出完整有效的数字。由于这种策略意味着每个字符输入都不会发出信号，所以在数字完成之前，字符既不能显示也不能编辑。这种情况显然是不可接受的，因为用户肯定希望在输入时看到屏幕上的每个字符。

现在让我们将注意力转向将我们的设计转化为`InputWidget`的最小界面。

#### InputWidget 的接口

我们通过展示类声明开始讨论`InputWidget`的接口。正如所料，我们清晰的设计带来了简单明了的界面。

```
class InputWidget : public QWidget
{
  Q_OBJECT
public:
  explicit InputWidget(QWidget* parent = nullptr);

signals:
  void characterEntered(char c);

  void enterPressed();
  void backspacePressed();
  void plusMinusPressed();
  void shiftPressed();

  void commandEntered(string, string);
};

```

本质上，整个类接口是由对应于用户输入事件的信号定义的。具体来说，我们有一个信号指示任何科学记数法字符的输入，一个信号指示前进命令按钮的点击，以及单独的信号分别指示退格、回车、加/减或 shift 按钮的点击。

如果您查看 GitHub 资源库源代码中的`InputWidget.cpp`文件，您会发现一些额外的公共函数和信号。这些额外的函数是实现后续章节中介绍的两个特性所必需的。首先，需要一个`addCommandButton()`函数和一个`setupFinalButtons()`函数来适应插件按钮的动态添加，这是在第 7 章[中介绍的一个特性。其次，需要一个`procedurePressed()`信号来指示用户请求使用存储过程。存储过程在第](7.html) [8](8.html) 章中介绍。

### 显示器

从概念上讲，计算器有两个显示器:一个用于输入，一个用于输出。这种抽象可以在视觉上实现为两个单独的显示或者一个合并的输入/输出显示。两种设计都完全有效；每个都在图 [6-3](#Fig3) 中进行了说明。

![../images/454125_2_En_6_Chapter/454125_2_En_6_Fig3_HTML.jpg](../images/454125_2_En_6_Chapter/454125_2_En_6_Fig3_HTML.jpg)

图 6-3

输入和输出显示选项

选择一种 I/O 风格还是另一种，最终取决于客户的偏好。我对这两种风格都没有特别的偏好，所以选择了合并显示，因为它看起来更像我的 HP48S 计算器。选择了显示风格后，现在让我们来关注这个选择所暗示的设计含义。

如图 [6-3a](#Fig3) 所示，使用一个独立的屏幕小部件进行输入和输出，选择独立的输入和输出显示类是显而易见的。输入显示将有接收`InputWidget`信号的插槽，输出显示将有接收完整数字(来自输入显示)和堆栈更新的插槽。内聚力会很强，组件的分离会很合适。

然而，我们的设计要求混合输入/输出显示器，如图 [6-3b](#Fig3) 所示。混合设计极大地改变了使用独立输入和输出显示类的敏感性。虽然将输入和输出显示问题集中到一个类中确实会降低显示的内聚性，但是试图维护两个独立的类都指向同一个屏幕上的小部件会导致笨拙的实现。例如，选择哪个类应该拥有底层的 Qt 小部件是任意的，很可能导致一个共享的小部件设计(也许使用一个`shared_ptr`？).然而，在这种情况下，输入或输出显示类应该初始化屏幕上的小部件吗？如果输入显示共享指向单个显示小部件的指针，那么输入显示向输出显示发送信号是否有意义？答案很简单，两个类的设计对于一个合并的 I/O 显示小部件是不成立的，即使我们可能更喜欢将输入和输出显示分开。

上述讨论确定了几个有趣的点。首先，设计在屏幕上的视觉呈现可以合理地改变底层组件的设计和实现。虽然这在一个具体的 GUI 示例中似乎是显而易见的，但间接的含义是，如果屏幕上的小部件只是稍微改变一下，GUI 类的设计可能需要显著改变。第二，当设计与第 [2](2.html) 章中假设的良好设计要素直接矛盾时，结果会更清晰。显然，第二章[中的指导方针是为了帮助设计过程，而不是作为不可违反的规则。也就是说，我的总的建议是保持遵循指导方针的清晰性，但只是明智地违反最佳实践。](2.html)

既然我们已经决定用一个底层的`Display`类来实现一个单一的 I/O 显示，让我们来看看它的设计。

#### 显示类的设计

我承认。我最初对`Display`类的设计和实现是无能的。我没有使用适当的分析技术和前期设计，而是有机地发展设计(即，与实现并行)。然而，当我的设计迫使`Display`类发出`commandEntered()`信号让 GUI 正常工作时，我就知道这个设计有一股“臭味”。负责在屏幕上绘制数字的类可能不应该解释命令。也就是说，实现工作正常，所以我让代码保持原样，并完成了计算器。然而，当我最终开始写这个设计时，我很难为我的设计制定一个基本原理，我最终不得不承认自己的设计有致命的缺陷，迫切需要重写。

显然，在重新设计展示后，我可以简单地选择只描述改进的产品。然而，我认为研究我的第一次被误导的尝试，讨论设计有一些严重问题的迹象，并最终看到经过一夜的重构最终出现的设计是有启发性的。可能，这里最有趣的教训是，糟糕的设计肯定会导致工作代码，所以永远不要认为工作代码是好设计的指标。此外，糟糕的设计，如果本地化，可以重构，有时，重构应该仅仅是为了增加清晰度。当然，重构假设您的项目时间表包含足够的应急时间，可以定期暂停以偿还技术债务。在回到更好的设计之前，我们现在开始简要研究我的错误。

#### 拙劣的设计

根据前面的分析，我们确定计算器应该有一个统一的`Display`类来处理输入和输出。我的显示设计中的基本错误源于错误地解释了一个`Display`类意味着没有额外的正交关注类。因此，我继续将所有没有被`InputWidget`类处理的功能合并到一个单独的`Display`类中。让我们沿着这条路开始。然而，我们不是像我以前那样完成设计和实现，而是一看到第一个致命缺陷出现，就停下来重新设计这个类(这是我本来应该做的)。

使用单一的`Display`类设计，`Display`负责显示来自用户的输入和来自计算引擎的输出。显示输出是微不足道的。`Display`类观察`stackChanged()`事件(间接的，因为它不是 GUI 外部接口的一部分)并用新的堆栈值更新屏幕显示小部件(在本例中是一个`QLabel`)。从概念上讲，显示输入也是微不足道的。`Display`直接接收`InputWidget`类(如`characterEntered()`)发出的信号，并用当前输入更新屏幕显示小工具。这种交互的简单性掩盖了这种设计的根本问题，即输入不是为了显示而自动输入的。相反，它是通过独立输入几个字符，并按下 enter 按钮来完成输入，从而将多个信号组合在一起。输入的这种顺序结构意味着计算器必须保持一个活动的输入状态，而输入状态与显示小部件无关。

此时，您可能会问，除了意识形态上的厌恶之外，`Display`类保持输入状态还有什么问题。难道我们不能把状态简单地看作一个显示输入缓冲区吗？让我们继续这个设计，看看它为什么有缺陷。例如，考虑退格按钮，它的操作基于输入状态被重载。如果当前输入缓冲区不为空，退格键将从该缓冲区中删除一个字符。但是，如果当前输入缓冲区为空，按 backspace 按钮会导致发出从堆栈中删除顶部数字的命令。因为在这种设计下，`Display`拥有输入状态并且是`backspacePressed()`信号的接收器，所以`Display`必须是来自堆栈命令的丢弃号的源。一旦`Display`开始发布命令，我们已经完全放弃了内聚力，是时候去寻找意大利面酱了，因为意大利面条代码随之而来。从这里开始，我不再只是放弃设计，而是加倍努力，我原来的设计实际上变得更差了。然而，与其在这条错误的道路上走得更远，不如让我们继续研究一种更好的方法。

#### 改进的展示设计

在讨论糟糕的显示设计的早期，我指出致命的错误来自于假设统一的显示需要单一的类设计。然而，正如我们已经看到的，这个假设是无效的。计算器中状态的出现意味着至少需要两个类:一个用于可视显示，一个用于状态。

这是否让你想起了我们已经见过的模式？GUI 需要维护一个内部状态(一个模型)。我们目前正在设计一个展示(一个视图)。我们已经设计了一个类`InputWidget`，用于接受输入和发布命令(一个控制器)。显然，GUI 本身只不过是一种熟悉的模式——模型-视图-控制器(MVC)的体现。注意，相对于图 2-2 中的 MVC 原型，GUI 可以用间接通信来代替控制器和模型之间的直接通信。Qt 的信号和插槽机制促进了这一微小的变化，从而降低了耦合度。

我们现在将注意力集中在新引入的模型类的设计上。模型完成后，我们将返回到`Display`类来完成它现在更简单的设计和界面。

### 6.3.4 模型

我恰当地称之为`GuiModel`的模型类负责 GUI 的状态。为了正确地实现这一目标，模型必须是导致系统状态改变的所有信号的接收器，并且它必须是指示系统状态已经改变的所有信号的源。自然，模型也是系统状态的存储库，它应该为 GUI 的其他组件提供查询模型状态的工具。我们来看看`GuiModel`的界面:

```
class GuiModel : public QObject
{
  Q_OBJECT
public:
  enum class ShiftState { Unshifted, Shifted };
  struct State { /* discussed below */ };

  GuiModel(QObject* parent = nullptr);
  ~GuiModel();

  void stackChanged(const vector<double>& v);

  const State& getState() const;

public slots:
  // called to toggle the calculator's shift state
  void onShift();

  // paired to InputWidget's signals
  void onCharacterEntered(char c);
  void onEnter();
  void onBackspace();
  void onPlusMinus();
  void onCommandEntered(string primaryCmd, string secondaryCmd);

signals:
  void modelChanged();
  void commandEntered(string s);
  void errorDetected(string s);
};

```

`GuiModel`类的六个槽都对应于`InputWidget`类发出的信号。`GuiModel`解释这些请求，适当地改变内部状态，并发出一个或多个自己的信号。特别值得注意的是`commandEntered()`信号。鉴于`GuiModel`的`onCommandEntered()`插槽接受两个参数，即对应于被按下的`CommandButton`的原始主命令和辅助命令，而`GuiModel`负责解释 GUI 的转换状态，并且仅重新发射带有活动命令的`commandEntered()`信号。

`GuiModel`界面的其余部分涉及 GUI 的状态。我们首先讨论嵌套的`State`结构背后的基本原理。比起在`GuiModel`中将模型状态的每一部分声明为一个单独的成员，我发现将所有的状态参数放在一个结构中要干净得多。这种设计通过允许使用一个函数调用通过常量引用返回整个系统状态，而不是要求逐段访问各个状态成员，从而方便了模型状态的查询。我选择嵌套`State`结构，因为它是`GuiModel`的固有部分，没有独立的用途。因此，`State`结构自然属于`GuiModel`的范围，但是它的声明必须公开声明，以便 GUI 的其他组件能够查询状态。

结构的组成部分定义了 GUI 的整个状态。特别地，这个`State`结构包括一个数据结构，该数据结构保存堆栈上最大数量的可见数字的副本、当前输入缓冲区、定义系统移位状态的枚举以及定义输入缓冲区有效性的 Qt 枚举。声明如下:

```
struct State
{
  vector<double> curStack;
  string curInput;
  ShiftState shiftState;
  QValidator::State curInputValidity;
};

```

一个有趣的问题是，为什么`GuiModel`的`State`缓冲来自栈顶的可见数字？鉴于`Stack`类是单例的，`Display`可以直接访问`Stack`。然而，`Display`仅观察到`GuiModel`中的变化(通过`modelChanged()`插槽)。因为与堆栈变化无关的状态变化频繁出现在 GUI 中(例如，字符输入)，由于`Display`不是`stackChanged()`事件的直接观察者，因此`Display`将被迫在每个`modelChanged()`事件上浪费地查询`Stack`。另一方面，`GuiModel`是`stackChanged()`事件的观察者(间接通过`MainWindow`的函数调用)。因此，有效的解决方案是让`GuiModel`仅在计算器的堆栈实际改变时更新堆栈缓冲区，并让`Display`类访问该缓冲区，这通过构造保证是当前的，用于更新屏幕。

### 显示冗余

我们现在准备将注意力返回到`Display`类。将所有的状态和状态交互放在`GuiModel`类中后，`Display`类可以简化为一个对象，它监视模型的变化并在屏幕上显示计算器的当前状态。除了构造函数之外，`Display`类的接口只包含两个函数:模型改变时调用的 slot 和在状态区域显示消息时调用的成员函数。后一个函数调用用于显示在 GUI 中检测到的错误(例如无效输入)以及在命令调度程序中检测到的错误(通过`UserInterface`的`postMessage()`发送)。下面给出了`Display`类的整个接口:

```
class Display : public QWidget
{
    Q_OBJECT
public:
  explicit Display(const GuiModel& g, QWidget* parent = nullptr,
    int nLinesStack = 6, int minCharWide = 25);

  void showMessage(const string& m);

public slots:
  void onModelChanged();
};

```

`Display`类的构造函数的可选参数只是指示堆栈在屏幕上的可视外观。具体来说，`Display`类的客户端可以灵活控制要显示的堆栈行数和屏幕显示的最小宽度(以固定宽度字体字符为单位)。

### 6.3.6 结合在一起:主窗口

主窗口是一个相当小的类，服务于一个大的目的。准确地说，它在我们的应用中有三个目的。首先，像在大多数基于 Qt 的 GUI 中一样，我们需要提供一个从`QMainWindow`中公开继承的类，它自然地充当应用程序的主 GUI 窗口。特别是，这是在启动 GUI 的函数中实例化和显示的类。遵循我典型的创造性命名风格，我将这个类称为`MainWindow`。其次，`MainWindow`作为计算器视图模块的接口类。也就是说，`MainWindow`也必须公开继承我们的抽象`UserInterface`类。最后，`MainWindow`类拥有前面讨论的所有 GUI 组件，并在必要时将这些组件粘合在一起。实际上，将组件粘合在一起只需要将信号连接到相应的插槽。这些简单的实现细节可以在`MainWindow.cpp`源代码文件中找到。我们将在本节的剩余部分讨论`MainWindow`的设计和界面。

我们已经编写了一个 Qt 应用程序；很明显我们会在某个地方有一个`QMainWindow`的后代。这本身并不十分有趣。然而，有趣的是决定使用多重继承来使同一个类也作为 pdCalc 的其余部分的`UserInterface`。也就是说，这真的是一个有趣的决定吗，或者只是因为一些开发人员对多重继承有强烈的厌恶而显得有些挑衅？

事实上，我本可以将`QMainWindow`和`UserInterface`分成两个独立的类。在主窗口装饰有菜单、工具栏和多个底层小部件的 GUI 中，我可能会将两者分开。然而，在我们的 GUI 中，`QMainWindow`除了为我们的 Qt 应用程序提供一个入口点之外，没有其他用途。在`QMainWindow`的角色中，`MainWindow`实际上什么也不做。因此，创建一个单独的`MainWindow`类，唯一的目的是包含一个`UserInterface`类的具体专门化，除了避免多重继承之外，没有任何其他目的。虽然有些人可能不同意，但我认为在这种情况下，缺乏多重继承实际上会使设计复杂化。

前面描述的情况实际上是多重继承是最佳选择的一个典型例子。特别是，多重继承在派生类中表现出色，这些派生类的多个基类表现出正交功能。在我们的例子中，一个基类充当 Qt 的 GUI 入口点，而另一个基类充当 pdCalc 的 GUI 视图的`UserInterface`专门化。请注意，两个基类都不共享功能、状态、方法或祖先。在至少有一个基类是纯抽象的(没有状态，只有纯虚函数的类)的情况下，多重继承特别有意义。使用纯抽象基类的多重继承的场景非常有用，以至于在不允许多重继承的编程语言(例如，C#和 Java 中的接口)中允许使用它。

`MainWindow`的接口简单地由一个构造函数、`UserInterface`类中两个纯虚函数的覆盖和一些用于动态添加命令的函数组成(当我们设计插件时，我们将在第 [7](7.html) 章中遇到这些函数)。为了完整起见，`MainWindow`的界面如下:

```
class MainWindow : public QMainWindow, public UserInterface
{
  class MainWindowImpl;
public:
  MainWindow(int argc, char* argv[], QWidget* parent = nullptr);

  void postMessage(string_view m) override;
  void stackChanged() override;

  // plugin functions...
};

```

### 外观和感觉

在我们用一些执行 GUI 的示例代码来结束本章之前，我们必须简单地回到 GUI 的最后一个组件，即`LookAndFeel`类。`LookAndFeel`类只是管理 GUI 的可动态定制的外观，比如字体大小和文本颜色。界面简单。对于每个定制点，都有一个函数返回请求的设置。例如，为了获得显示的字体，我们提供了一个函数:

```
class LookAndFeel
{
public:
  // one function per customizable setting, e.g.,
  const QFont& getDisplayFont() const;
  // ...
}

```

因为我们在计算器中只需要一个`LookAndFeel`对象，所以这个类是作为单例实现的。

一个很好的问题是，“我们到底为什么需要这个类？”答案是，它让我们有机会根据当前环境动态修改计算器的外观，并且它集中了对 pdCalc 外观的内存访问。例如，假设我们想要让我们的 GUI DPI 知道并相应地选择字体大小(我在源代码中没有，但是您可能想要)。对于静态配置文件(或概念上的等效物，注册表设置)，我们必须在安装过程中为每个平台定制设置。要么我们必须在安装程序中为每个平台构建定制，要么我们必须编写在安装期间执行的代码，以动态创建适当的静态配置文件。如果我们必须写代码，为什么不把它放在它应该在的地方呢？作为一个实现决策，`LookAndFeel`类可以简单地设计为读取一个配置文件并在内存中缓冲外观属性(一个外观代理对象)。这才是`LookAndFeel`级的真正威力。它集中了外观属性的位置，因此只需要更改一个类就可以实现全局外观更改。也许更重要的是，`LookAndFeel`类将单个 GUI 组件与定义 GUI 如何发现(并可能适应)特定平台上的设置的实现细节隔离开来。

在`LookAndFeel.cpp`文件中可以找到`LookAndFeel`类的完整实现。当前的实现非常简单。`LookAndFeel`类提供了一种标准化 GUI 外观的机制，但是没有实现允许用户定制应用程序。第 8 章[简要地建议了一些可能的扩展，你可以对`LookAndFeel`类进行扩展，使 pdCalc 用户可定制。](8.html)

## 6.4 工作计划

我们以一个用于启动 GUI 的功能`main()`来结束这一章。由于我们将在第 [7](7.html) 章中遇到的额外要求，pdCalc 的实际`main()`函数比下面列出的更复杂。但是，简化版本值得列出来，以说明如何将 pdCalc 的组件与 GUI 结合在一起，以创建一个正常运行的独立可执行文件。

```
int main(int argc, char* argv[])
{
  QApplication app{argc, argv};
  MainWindow gui{argc, argv};

  CommandInterpreter ci{gui};

  RegisterCoreCommands(gui);

  gui.attach(UserInterface::CommandEntered(),
    make_unique<CommandIssuedObserver>(ci) );

  Stack::Instance().attach(Stack::StackChanged(),
    make_unique<StackUpdatedObserver>( gui ) );

  gui.execute();

  return app.exec();
}

```

注意前面提到的用于执行 GUI 的`main()`函数与第 [5](5.html) 章结尾列出的用于执行 CLI 的`main()`函数之间的相似之处。这些相似之处并非偶然，而是 pdCalc 模块化设计的结果。

与 CLI 一样，为了让您快速入门，在构建可执行文件`pdCalc-simple-gui`的存储库源代码中包含了一个项目，使用前面的`main()`函数作为应用程序的驱动程序。该可执行文件是一个独立的 GUI，包括本书到目前为止讨论的所有特性。

## 6.5 Microsoft Windows 内部版本说明

pdCalc 被设计为既是 GUI 又是 CLI。在 Linux 中，控制台应用程序(CLI)和窗口应用程序(GUI)在编译时没有区别。对于这两种风格，可以用相同的构建标志来编译统一的应用程序。然而，在 Microsoft Windows 中，创建一个既作为 CLI 又作为 GUI 的应用程序并不容易，因为操作系统要求应用程序在编译期间声明控制台或 Windows 子系统的使用。

为什么子系统的声明在 Windows 上很重要？如果一个应用程序被声明为窗口应用程序，如果从命令提示符启动，该应用程序将简单地返回而没有输出(即，该应用程序将看起来好像从未执行过)。但是，当双击应用程序的图标时，应用程序会在没有后台控制台的情况下启动。另一方面，如果一个应用程序被声明为控制台应用程序，则当从命令提示符启动时，GUI 将会出现，但是如果通过双击该应用程序的图标来打开，GUI 将与后台控制台一起启动。

通常，Microsoft Windows 应用程序是为一个子系统或另一个子系统设计的。在少数同时使用 GUI 和 CLI 开发应用程序的情况下，开发人员已经创建了避免上述问题的技术。一种这样的技术创建了两个应用程序:一个. com 和一个. exe，操作系统可以根据通过命令行参数选择的选项适当地调用它们。

为了保持 pdCalc 的代码简单和跨平台，我忽略了这个问题，简单地使用控制台子系统构建了 GUI(然而，`pdCalc-simple-gui`没有 CLI，是在窗口模式下构建的)。事实上，这意味着如果通过双击 pdCalc 的图标来启动应用程序，将会在后台出现一个额外的控制台窗口。如果您打算将应用程序专门用作 GUI，可以通过使用 windows 子系统构建程序来解决这个问题。如果您进行此更改，请记住，pdCalc 的 CLI 实际上将被禁用。构建窗口应用程序可以通过在负责构建 pdCalc 可执行文件的`CMakeLists.txt`文件的`add_executable()`命令中添加`WIN32`选项来完成(参见`pdCalc-simple-gui`的`CMakeLists.txt`文件)。如果您需要访问 CLI 和 GUI，而外部控制台让您抓狂，您有两个现实的选择。首先，在互联网上搜索前面讨论过的技术之一，并尝试一下。就我个人而言，我从未走过那条路。其次，构建两个独立的可执行文件(可能称为 pdCalc 和 pdCalc-cli ),而不是一个能够基于命令行参数切换模式的可执行文件。应用程序灵活的架构支持这两种选择。